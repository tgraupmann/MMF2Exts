#include "Common.h"
#include "Public/ChromaAnimationAPI.h"

using namespace ChromaSDK;

RZRESULT Extension::_sInitResult = -1;

///
/// EXTENSION CONSTRUCTOR/DESTRUCTOR
///

Extension::Extension(RUNDATA * _rdPtr, EDITDATA * edPtr, CreateObjectInfo * cobPtr)
	: rdPtr(_rdPtr), rhPtr(_rdPtr->rHo.AdRunHeader), Runtime(_rdPtr), FusionDebugger(this)
{
	if (!ChromaAnimationAPI::IsInitializedAPI())
	{
		RZRESULT result = ChromaAnimationAPI::InitAPI();
		if (result == 0)
		{
			OutputDebugStringA("Loaded Chroma SDK Plugin!\r\n");
		}
		else
		{
			OutputDebugStringA("Failed to loaded Chroma SDK Plugin!\r\n");
		}
	}

	/*
		Link all your action/condition/expression functions to their IDs to match the
		IDs in the JSON here
	*/

	// don't change the order
	LinkAction(0, PlayAnimationName);
	LinkAction(1, PlayComposite);
	LinkAction(2, StaticColor);
	LinkAction(3, StaticColorAllDevices);
	LinkAction(4, CloseAnimationName);
	LinkAction(5, GetAnimation);
	LinkAction(6, DuplicateFirstFrameName);
	LinkAction(7, DuplicateFramesName);
	LinkAction(8, MakeBlankFramesName);
	LinkAction(9, ReduceFramesName);
	LinkAction(10, InsertDelayName);
	LinkAction(11, TrimStartFramesName);
	LinkAction(12, TrimEndFramesName);
	LinkAction(13, MultiplyTargetColorLerpAllFramesName);
	LinkAction(14, MultiplyNonZeroTargetColorLerpAllFramesName);
	LinkAction(15, FillZeroColorAllFramesName);
	LinkAction(16, OffsetColorsAllFramesName);
	LinkAction(17, CopyNonZeroTargetAllKeysAllFramesName);
	LinkAction(18, CopyNonZeroAllKeysAllFramesName);
	LinkAction(19, ActInit);
	LinkAction(20, RegisterLuaFunctions);
	LinkAction(21, StopAnimationName);
	LinkAction(22, ActLuaLoadString);
	LinkAction(23, ActLuaLoadFile);
	LinkAction(24, CopyAnimationName);
	LinkAction(25, AppendAllFramesName);
	LinkAction(26, LoadAnimationName);
	LinkAction(27, UnloadAnimationName);
	LinkAction(28, SetColorData);

	LinkAction(29, ActSetAppInfoTitle);
	LinkAction(30, ActSetAppInfoDescription);
	LinkAction(31, ActSetAppInfoAuthorName);
	LinkAction(32, ActSetAppInfoAuthorContact);

	// don't change the order
	LinkCondition(0, CondIsInitialized);
	LinkCondition(1, CondInit);

	// don't change the order
	LinkExpression(0, ExpIsInitialized);
	LinkExpression(1, ExpInit);
	LinkExpression(2, ExpGetRGB);
	LinkExpression(3, ExpGetIntDeviceType);
	LinkExpression(4, ExpGetIntDevice);
	LinkExpression(5, ExpGetFrameCountName);
	LinkExpression(6, ExpGetColorDataSize);

#pragma region Autogenerated Keyboard Enum Expression Bindings

	LinkExpression(7, ExpGet_RZKEY_ESC);
	LinkExpression(8, ExpGet_RZKEY_F1);
	LinkExpression(9, ExpGet_RZKEY_F2);
	LinkExpression(10, ExpGet_RZKEY_F3);
	LinkExpression(11, ExpGet_RZKEY_F4);
	LinkExpression(12, ExpGet_RZKEY_F5);
	LinkExpression(13, ExpGet_RZKEY_F6);
	LinkExpression(14, ExpGet_RZKEY_F7);
	LinkExpression(15, ExpGet_RZKEY_F8);
	LinkExpression(16, ExpGet_RZKEY_F9);
	LinkExpression(17, ExpGet_RZKEY_F10);
	LinkExpression(18, ExpGet_RZKEY_F11);
	LinkExpression(19, ExpGet_RZKEY_F12);
	LinkExpression(20, ExpGet_RZKEY_1);
	LinkExpression(21, ExpGet_RZKEY_2);
	LinkExpression(22, ExpGet_RZKEY_3);
	LinkExpression(23, ExpGet_RZKEY_4);
	LinkExpression(24, ExpGet_RZKEY_5);
	LinkExpression(25, ExpGet_RZKEY_6);
	LinkExpression(26, ExpGet_RZKEY_7);
	LinkExpression(27, ExpGet_RZKEY_8);
	LinkExpression(28, ExpGet_RZKEY_9);
	LinkExpression(29, ExpGet_RZKEY_0);
	LinkExpression(30, ExpGet_RZKEY_A);
	LinkExpression(31, ExpGet_RZKEY_B);
	LinkExpression(32, ExpGet_RZKEY_C);
	LinkExpression(33, ExpGet_RZKEY_D);
	LinkExpression(34, ExpGet_RZKEY_E);
	LinkExpression(35, ExpGet_RZKEY_F);
	LinkExpression(36, ExpGet_RZKEY_G);
	LinkExpression(37, ExpGet_RZKEY_H);
	LinkExpression(38, ExpGet_RZKEY_I);
	LinkExpression(39, ExpGet_RZKEY_J);
	LinkExpression(40, ExpGet_RZKEY_K);
	LinkExpression(41, ExpGet_RZKEY_L);
	LinkExpression(42, ExpGet_RZKEY_M);
	LinkExpression(43, ExpGet_RZKEY_N);
	LinkExpression(44, ExpGet_RZKEY_O);
	LinkExpression(45, ExpGet_RZKEY_P);
	LinkExpression(46, ExpGet_RZKEY_Q);
	LinkExpression(47, ExpGet_RZKEY_R);
	LinkExpression(48, ExpGet_RZKEY_S);
	LinkExpression(49, ExpGet_RZKEY_T);
	LinkExpression(50, ExpGet_RZKEY_U);
	LinkExpression(51, ExpGet_RZKEY_V);
	LinkExpression(52, ExpGet_RZKEY_W);
	LinkExpression(53, ExpGet_RZKEY_X);
	LinkExpression(54, ExpGet_RZKEY_Y);
	LinkExpression(55, ExpGet_RZKEY_Z);
	LinkExpression(56, ExpGet_RZKEY_NUMLOCK);
	LinkExpression(57, ExpGet_RZKEY_NUMPAD0);
	LinkExpression(58, ExpGet_RZKEY_NUMPAD1);
	LinkExpression(59, ExpGet_RZKEY_NUMPAD2);
	LinkExpression(60, ExpGet_RZKEY_NUMPAD3);
	LinkExpression(61, ExpGet_RZKEY_NUMPAD4);
	LinkExpression(62, ExpGet_RZKEY_NUMPAD5);
	LinkExpression(63, ExpGet_RZKEY_NUMPAD6);
	LinkExpression(64, ExpGet_RZKEY_NUMPAD7);
	LinkExpression(65, ExpGet_RZKEY_NUMPAD8);
	LinkExpression(66, ExpGet_RZKEY_NUMPAD9);
	LinkExpression(67, ExpGet_RZKEY_NUMPAD_DIVIDE);
	LinkExpression(68, ExpGet_RZKEY_NUMPAD_MULTIPLY);
	LinkExpression(69, ExpGet_RZKEY_NUMPAD_SUBTRACT);
	LinkExpression(70, ExpGet_RZKEY_NUMPAD_ADD);
	LinkExpression(71, ExpGet_RZKEY_NUMPAD_ENTER);
	LinkExpression(72, ExpGet_RZKEY_NUMPAD_DECIMAL);
	LinkExpression(73, ExpGet_RZKEY_PRINTSCREEN);
	LinkExpression(74, ExpGet_RZKEY_SCROLL);
	LinkExpression(75, ExpGet_RZKEY_PAUSE);
	LinkExpression(76, ExpGet_RZKEY_INSERT);
	LinkExpression(77, ExpGet_RZKEY_HOME);
	LinkExpression(78, ExpGet_RZKEY_PAGEUP);
	LinkExpression(79, ExpGet_RZKEY_DELETE);
	LinkExpression(80, ExpGet_RZKEY_END);
	LinkExpression(81, ExpGet_RZKEY_PAGEDOWN);
	LinkExpression(82, ExpGet_RZKEY_UP);
	LinkExpression(83, ExpGet_RZKEY_LEFT);
	LinkExpression(84, ExpGet_RZKEY_DOWN);
	LinkExpression(85, ExpGet_RZKEY_RIGHT);
	LinkExpression(86, ExpGet_RZKEY_TAB);
	LinkExpression(87, ExpGet_RZKEY_CAPSLOCK);
	LinkExpression(88, ExpGet_RZKEY_BACKSPACE);
	LinkExpression(89, ExpGet_RZKEY_ENTER);
	LinkExpression(90, ExpGet_RZKEY_LCTRL);
	LinkExpression(91, ExpGet_RZKEY_LWIN);
	LinkExpression(92, ExpGet_RZKEY_LALT);
	LinkExpression(93, ExpGet_RZKEY_SPACE);
	LinkExpression(94, ExpGet_RZKEY_RALT);
	LinkExpression(95, ExpGet_RZKEY_FN);
	LinkExpression(96, ExpGet_RZKEY_RMENU);
	LinkExpression(97, ExpGet_RZKEY_RCTRL);
	LinkExpression(98, ExpGet_RZKEY_LSHIFT);
	LinkExpression(99, ExpGet_RZKEY_RSHIFT);
	LinkExpression(100, ExpGet_RZKEY_MACRO1);
	LinkExpression(101, ExpGet_RZKEY_MACRO2);
	LinkExpression(102, ExpGet_RZKEY_MACRO3);
	LinkExpression(103, ExpGet_RZKEY_MACRO4);
	LinkExpression(104, ExpGet_RZKEY_MACRO5);
	LinkExpression(105, ExpGet_RZKEY_OEM_1);
	LinkExpression(106, ExpGet_RZKEY_OEM_2);
	LinkExpression(107, ExpGet_RZKEY_OEM_3);
	LinkExpression(108, ExpGet_RZKEY_OEM_4);
	LinkExpression(109, ExpGet_RZKEY_OEM_5);
	LinkExpression(110, ExpGet_RZKEY_OEM_6);
	LinkExpression(111, ExpGet_RZKEY_OEM_7);
	LinkExpression(112, ExpGet_RZKEY_OEM_8);
	LinkExpression(113, ExpGet_RZKEY_OEM_9);
	LinkExpression(114, ExpGet_RZKEY_OEM_10);
	LinkExpression(115, ExpGet_RZKEY_OEM_11);
	LinkExpression(116, ExpGet_RZKEY_EUR_1);
	LinkExpression(117, ExpGet_RZKEY_EUR_2);
	LinkExpression(118, ExpGet_RZKEY_JPN_1);
	LinkExpression(119, ExpGet_RZKEY_JPN_2);
	LinkExpression(120, ExpGet_RZKEY_JPN_3);
	LinkExpression(121, ExpGet_RZKEY_JPN_4);
	LinkExpression(122, ExpGet_RZKEY_JPN_5);
	LinkExpression(123, ExpGet_RZKEY_KOR_1);
	LinkExpression(124, ExpGet_RZKEY_KOR_2);
	LinkExpression(125, ExpGet_RZKEY_KOR_3);
	LinkExpression(126, ExpGet_RZKEY_KOR_4);
	LinkExpression(127, ExpGet_RZKEY_KOR_5);
	LinkExpression(128, ExpGet_RZKEY_KOR_6);
	LinkExpression(129, ExpGet_RZKEY_KOR_7);
	LinkExpression(130, ExpGet_RZKEY_INVALID);

#pragma endregion

	/*
		This is where you'd do anything you'd do in CreateRunObject in the original SDK

		It's the only place you'll get access to edPtr at runtime, so you should transfer
		anything from edPtr to the extension class here.

	*/

	// Don't use "this" inside these lambda functions, always ext.
	// There can be nothing in the [] section of the lambda.
	// If you're not sure about lambdas, you can remove this debugger stuff without any side effects;
	// it's just an example of how to use the debugger. You can view it in Fusion itself to see.
	FusionDebugger.AddItemToDebugger(
		// reader function for your debug item
		[](Extension *ext, std::tstring &writeTo) {
			writeTo = _T("My text is: ") + ext->exampleDebuggerTextItem;
		},
		// writer function (can be null if you don't want user to be able to edit it in debugger)
		[](Extension *ext, std::tstring &newText)
		{
			ext->exampleDebuggerTextItem = newText;
			return true; // accept the changes
		}, 500, NULL
	);
	
}

Extension::~Extension()
{

}


REFLAG Extension::Handle()
{
	/*
		If your extension will draw to the MMF window you should first 
		check if anything about its display has changed :

			if (rdPtr->roc.rcChanged)
			  return REFLAG::DISPLAY;
			else
			  return REFLAG::NONE;

		You will also need to make sure you change this flag yourself 
		to 1 whenever you want to redraw your object
	 
		If your extension won't draw to the window, but it still needs 
		to do something every MMF loop use :

			return REFLAG::NONE;

		If you don't need to do something every loop, use :

			return REFLAG::ONE_SHOT;

		This doesn't mean this function can never run again. If you want MMF
		to handle your object again (causing this code to run) use this function:

			Runtime.Rehandle();

		At the end of the loop this code will run

	*/

	// Will not be called next loop	
	return REFLAG::ONE_SHOT;
}


REFLAG Extension::Display()
{
	/*
		If you return REFLAG_DISPLAY in Handle() this routine will run.
	*/

	// Ok
	return REFLAG::DISPLAY;
}

short Extension::Pause()
{

	// Ok
	return 0;
}

short Extension::Continue()
{

	// Ok
	return 0;
}


// These are called if there's no function linked to an ID

void Extension::Action(int ID, RUNDATA * rdPtr, long param1, long param2)
{

}

long Extension::Condition(int ID, RUNDATA * rdPtr, long param1, long param2)
{
	return false;
}

long Extension::Expression(int ID, RUNDATA * rdPtr, long param)
{
	return 0;
}
